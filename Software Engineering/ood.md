# OOD

* Changing requirements introduce forces that apply sudden and unexpected pressures that work against the best-laid plans. It is the need for change that makes design matter.
* Object needs to know other objects in order to communicate and send messages. This is natural. But this also create dependencies. OOD ultimately is about managing dependencies.
* In the absence of design, unmanaged dependencies wreak havoc because objects know too much about one another. This is a very common pitfall and is the first principle in SOLID design, the SRP.
* Design is a journey along a branching path wherein earlier choices close off some options and open access to others.
* OOD metrics cannot identify designs that do the wrong thing in the right way.
* Arranging code to efficiently accommodate change is a matter of design.
* Refactor towards patterns instead of implementing a pattern right away.

> Knowing how software should look when it's done does not cause it to build itself; applications come into existence because some programmer applied the tools. The end result, be it a beautiful cabinet or a rickety chair, reflects its programmer's experience with the tools of design.


OO applications are made up of *parts* that interact to produce the behavior of the whole.

In functional programming, the *parts* are functions itself.

Both paradigms need to be used "together" in terms of front-end UI code and backend business logics. Only only one paradigm is suicidal.

OOP is definitely good for business logics and processes. It is good for Domain-Driven development.

* [Design smell](http://blog.ploeh.dk/2011/05/24/Poka-yokeDesignFromSmelltoFragrance/)
* [Closures and Objects are equivalent](http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent)
* [RoleInterface](http://martinfowler.com/bliki/RoleInterface.html)
* [In Praise of Small Classes](http://www.drdobbs.com/architecture-and-design/in-praise-of-small-classes/230300002)

# Videos

* [Bob Martin on SOLID at Yale](https://www.youtube.com/watch?v=QHnLmvDxGTY)